---
title: "USMLE Data Analysis"
author: "Lisa Levoir"
date: "`r format(Sys.time(), '%B %d, %Y')`"
format: 
  html:
        theme: flatly
        code-fold: true
        code-tools: true
        html-math-method: katex
        toc: true
        toc-depth: 3
        fig-width: 13
        fig-height: 10
        toc-title: "Contents"
        number-sections: true
        self-contained: true
        self-contained-math: true
        smooth-scroll: true
        fontsize: 0.8em
        title-block-banner: true
        citation-location: margin
        include-after-body: graph_fold.html
editor: visual
engine: knitr
---

# Data import and cleaning

In this section I import the data and prepare it for analysis.

```{r setup}
#| warning: false
#| message: false
#| echo: fenced

library(tidyverse)
library(plotly)
library(dplyr)
library(tidyr)
library(knitr)
library(table1) #Create HTML Tables of Descriptive Statistics https://cran.r-project.org/web/packages/table1/vignettes/table1-examples.html
#library(OMTM1) #https://github.com/schildjs/OMTM1/
library(Hmisc)
library(rms) # Regression Modeling Strategies by Frank https://cran.r-project.org/web/packages/rms/index.html
library(modelsummary) #Summary Tables and Plots for Statistical Models and Data: Beautiful, Customizable, and Publication-Ready https://cran.r-project.org/web/packages/modelsummary/index.html
library(scales) # The scales packages provides the internal scaling infrastructure used by ggplot2, and gives you tools to override the default breaks, labels, transformations and palettes. https://scales.r-lib.org
library(viridis) #colors
library(cowplot) #allows me to use plotgrid
library(gridExtra) #adding tables to plots
library(visdat) #shows missing data
library(GGally) #makes pairs plots
library(sandwich) #for robust standard errors

setwd("/Users/lisalevoir/BIOS7351_Collab/data_project2") #this line I would need to run in the console
knitr::opts_knit$set(root.dir = "/Users/lisalevoir/BIOS7351_Collab/github/BIOS_Collaboration/project_2_analysis") #now I set global options for knitting, I also had to toggle global options > R Markdown > evaluate chunks in current directory


#import the data
dat <- read.csv("/Users/lisalevoir/BIOS7351_Collab/data_project2/combined_data_203.csv")

#to compare that the merging went as expected
VUMSdat <- read.csv("/Users/lisalevoir/BIOS7351_Collab/data_project2/DATA_VUMS.csv")
HMSdat <- read.csv("/Users/lisalevoir/BIOS7351_Collab/data_project2/DATA_HMS.csv")
UVAdat <- read.csv("/Users/lisalevoir/BIOS7351_Collab/data_project2/DATA_UVA.csv")
```

### Inclusion/Exclusion

Criteria to exclude students who most likely took a scored exam:

-   Any PhD students (n = 2)

-   Any 5th year program students (n = 19)

-   M4 students at Vanderbilt (n = 5)

-   Students who did not complete either Step survey (n = 2)

-   Students who specifically stated they took a scored Step 1 (n=1)

Based on our criteria we would exclude record IDs:

-   VUSM: 23, 26, 39, 40, 54, 3, 8, 12, 49, 60, 62, 64

-   HMS: 1, 21, 28, 30, 34, 37, 39, 41, 44, 47, 49, 61

-   UVA: 33, 47, 80, 81, 83

```{r data_cleaning}
#| warning: false
#| message: false
#| echo: false

dat <- dat %>% mutate(uniqueID = paste(school, record_id))
VUMSdat <- dat %>% mutate(uniqueID = paste("VUSM", record_id))
HMSdat <- dat %>% mutate(uniqueID = paste("HMS", record_id))
UVAdat <- dat %>% mutate(uniqueID = paste("UVASOM", record_id))

#the list of IDs we decided as a group to exclude
excludeVU <- c(23, 26, 39, 40, 54, 3, 8, 12, 49, 60, 62, 64)
excludeHMS <- c(1, 21, 28, 30, 34, 37, 39, 41, 44, 47, 49, 61)
excludeUVA <- c(33, 47, 80, 81, 83)

'%!in%' <- function(x,y)!('%in%'(x,y)) #make a way to use the not in command
VU_in <- filter(VUMSdat, record_id  %!in%  excludeVU)
H_in <- filter(HMSdat, record_id  %!in%  excludeHMS)
UVA_in <- filter(UVAdat, record_id  %!in%  excludeUVA)

#now I want to select the columns I'd like to include for all of my analysis (so they're in the proper order for a cbind). this will be relatively easy to come back to edit later, if needed. 

#first, remember to include a school identifier
VU_in[,"schoolid"] <- "VU" 
UVA_in[,"schoolid"] <- "UVa"
H_in[,"schoolid"] <- "HMS"

############ plan for how I will get the data in a format I want:
# - pull relevant columns by "starts with"
# - confirm all column names match, then
# - rbind together once
# - then I can select from this sheet the questions relevant to Step 1 first with ends with "_1", and those who took Step 1 second with a "_2"

############ Now pulling the common columns we're interested in as predictors and outcomes
##note, for VU I removed ""number_other_courses_step1_1" and starts_with("other_courses_step1_1___1) because these questions were not on the other school surveys
took_step1_VU <-
  VU_in %>% select(
    starts_with("record_id"),
    starts_with("uworld_percent_step1"),
    starts_with("amboss_percent_step1"),
    starts_with("length_step1"),
    starts_with("practicetest_step1"),
    starts_with("full_test_practice_step1"), # split into binary: Yes and I am glad I did, Yes and it was unnecessary, No and I wish I did, No and I am glad I did not
    starts_with("push_step1"),
    starts_with("push_practice_test_step1"),
    starts_with("push_nbme_practice_score_step1"),
    starts_with("push_uw_practice_score_step1"),
    starts_with("final_nbme_practice_score_step1"),
    starts_with("final_uw_practice_score_step1"),
    starts_with("score_step1"),
    starts_with("resources_step1"),
    "uniqueID",
    "schoolid", 
    "exam_order"
  ) 

took_step1_UVA <-
  UVA_in %>% select(
    starts_with("record_id"),
    starts_with("uworld_percent_step1"),
    starts_with("amboss_percent_step1"),
    starts_with("length_step1"),
    starts_with("practicetest_step1"),
    starts_with("full_test_practice_step1"),
    starts_with("push_step1"),
    starts_with("push_practice_test_step1"),
    starts_with("push_nbme_practice_score_step1"),
    starts_with("push_uw_practice_score_step1"),
    starts_with("final_nbme_practice_score_step1"),
    starts_with("final_uw_practice_score_step1"),
    starts_with("score_step1"),
    starts_with("resources_step1") ,
    "uniqueID",
    "schoolid", 
    "exam_order"
  )

took_step1_H <-
  H_in %>% select(
    starts_with("record_id"),
    starts_with("uworld_percent_step1"),
    starts_with("amboss_percent_step1"),
    starts_with("length_step1"),
    starts_with("practicetest_step1"),
    starts_with("full_test_practice_step1"),
    starts_with("push_step1"),
    starts_with("push_practice_test_step1"),
    starts_with("push_nbme_practice_score_step1"),
    starts_with("push_uw_practice_score_step1"),
    starts_with("final_nbme_practice_score_step1"),
    starts_with("final_uw_practice_score_step1"),
    starts_with("score_step1"),
    starts_with("resources_step1"),
    "uniqueID",
    "schoolid", 
    "exam_order"
  )

## now rbinding the three schools together
took_step1general <- rbind(took_step1_H, took_step1_UVA, took_step1_VU)

## splitting the dataset so I also have reference sheets specific to step 1 first and step 1 second
took_step1_first <- took_step1general %>% select(ends_with("_1"), "schoolid") #I actually haven't used this data frame in the analysis
took_step1_second <- took_step1general %>% select(ends_with("_2"), "schoolid") #I actually haven't used this data frame in the analysis

#this function will accommodate for the survey which split up the step 2 responses by whether it was taken first or second. I would like to run analysis (and gather percent missing) across all scores as they are available. I can add an indicator column later to identify people who took it first/second. The idea with this function is the output (called storage_df) should be easy to colbind onto the original data frame. Voila!
#also if we decide to change our minds and include more variables it will be quick to run.
merge_my_columns <- function(input_cols, source_df){
storage_df <- as.data.frame(matrix(nrow = nrow(source_df), ncol = length(input_cols)))
names(storage_df) <- input_cols
for(i in 1:length(input_cols)) {
  cols <- source_df %>% select(starts_with(input_cols[i])) %>% names()
  print(cols)
  new_cobined_col <-coalesce(source_df[, cols[1]], source_df[, cols[2]])
  storage_df[, i] <- new_cobined_col
}
print("Above is a list of columns I have combined for you. Hope it looks right!")
return(storage_df)
}

######## combine results across exam order for Step 2
class(took_step1general$practicetest_step1_1) <- "integer" #had to change class in order to coalesce these
class(took_step1general$practicetest_step1_2) <- "integer" 
class(took_step1general$push_uw_practice_score_step1_2) <- "integer"
class(took_step1general$push_uw_practice_score_step1_1) <- "integer"

cols_step1 <- c("uworld_percent_step1", "amboss_percent_step1", "length_step1", "practicetest_step1","full_test_practice_step1", "push_step1", "push_practice_test_step1",  "push_nbme_practice_score_step1",  "push_uw_practice_score_step1" ,"final_nbme_practice_score_step1", "final_uw_practice_score_step1","resources_step1",  "score_step1")

to_add <- merge_my_columns(input_cols = cols_step1, source_df = took_step1general)
#table(to_add$score_step1) ## all step 1 scores have an outcome so there is no one to drop/filter out
step1_complete <- bind_cols(took_step1general, to_add) %>% select(record_id, uniqueID:score_step1)
```

Data quality: there are ` r length(step1_complete$uniqueID)` unique individuals included in the step 1 data. Below is a table of their inclusion by school:
```{r}
kable(table(step1_complete$schoolid))
```


```{r data_cleaning_forstep2}
#| warning: false
#| message: false
#| echo: false

took_step2_VU <-
  VU_in %>% select(
    starts_with("record_id"),
    starts_with("uworld_percent_step2"),
    starts_with("amboss_percent_step2"),
    starts_with("length_step2"),
    starts_with("practicetest_step2"),
    starts_with("full_test_practice_step2"),
    starts_with("practice_score_step2"),
    starts_with("practice_test_step2"),
    starts_with("score_step2"),
    starts_with("target_score_step2"),
    starts_with("resources_step2"),
    "uniqueID",
    "schoolid", 
    "exam_order"
  ) #note, I removed ""number_other_courses_step1_1" and starts_with("other_courses_step1_1___1) because these questions were not on the other school surveys

took_step2_UVA <-
  UVA_in %>% select(
    starts_with("record_id"),
    starts_with("uworld_percent_step2"),
    starts_with("amboss_percent_step2"),
    starts_with("length_step2"),
    starts_with("practicetest_step2"),
    starts_with("full_test_practice_step2"),
    starts_with("practice_score_step2"),
    starts_with("practice_test_step2"),
    starts_with("score_step2"),
    starts_with("target_score_step2"),
    starts_with("resources_step2"),
    "uniqueID",
    "schoolid", 
    "exam_order"
  )

took_step2_H <-
  H_in %>% select(
    starts_with("record_id"),
    starts_with("uworld_percent_step2"),
    starts_with("amboss_percent_step2"),
    starts_with("length_step2"),
    starts_with("practicetest_step2"),
    starts_with("full_test_practice_step2"),
    starts_with("practice_score_step2"),
    starts_with("practice_test_step2"),
    starts_with("score_step2"),
    starts_with("target_score_step2"),
    starts_with("resources_step2"),
    "uniqueID",
    "schoolid", 
    "exam_order"
  )

took_step2general <- rbind(took_step2_H, took_step2_UVA, took_step2_VU)
took_step2_first <- took_step2general %>% select(ends_with("_1"), "schoolid", "uniqueID") #don't plan on using these, but available if needed
took_step2_second <- took_step2general %>% select(ends_with("_2"), "schoolid", "uniqueID")

########combine results across exam order for Step 2
class(took_step2general$practice_score_step2_2) <- "integer" #had to change class in order to coalesce these
class(took_step2general$score_step2_1) <- "integer"
class(took_step2general$score_step2_2) <- "integer"

columns_to_summarize <- c("uworld_percent_step2", "amboss_percent_step2", "length_step2", "practicetest_step2","full_test_practice_step2", "practice_score_step2", "practice_test_step2", "resources_step2",  "score_step2","target_score_step2")

to_add <- merge_my_columns(input_cols = columns_to_summarize, source_df = took_step2general)
#listing the people with no outcome reported
drop_these_with_no_outcome <- bind_cols(took_step2general, to_add) %>% filter(is.na(score_step2)) %>% select("record_id", "schoolid", "uniqueID")

#dropping the people with no outcome
intermediate_step2 <- bind_cols(took_step2general, to_add) %>% filter(!is.na(score_step2))
#creating the complete data set
step2_complete <- intermediate_step2 %>% select(record_id, schoolid:target_score_step2)
```
Notice that unfortunately, we had to drop `r nrow(drop_these_with_no_outcome) ` individuals who did not report a step 2 score. These raw counts and frequencies of people who did not give a step 2 score (and are therefor not eligible for analysis) are listed by institution below.
```{r}
# describing the missingness
kable(table(drop_these_with_no_outcome$schoolid), caption = "Number of missing Step 2 scores by institution")
num <- as.vector(table(drop_these_with_no_outcome$schoolid))
denom <- as.vector(table(step2_complete$schoolid))
nonresponse_freq <- setNames(c(round(num/denom, 3)), c(names(table(step2_complete$schoolid))))
kable(nonresponse_freq, caption = "frequency of missing step 2 scores by instition")

######### visually profile missing responses
p1 <- visdat::vis_miss(step1_complete)
p2 <- visdat::vis_miss(step2_complete)

title_gg <- ggdraw() + draw_label("Response missingness for pooled survey results across exam order")
gridded <- plot_grid(p1, p2, label_size = 12, ncol = 2, align = "hv", label_x = 0.5,
          labels = c("Step 1","Step 2"))
plot_grid(title_gg, gridded, nrow = 2, rel_heights = c(0.1, 0.9))
```

# Analysis

Note, we plan to use the robust/sandwich variance estimator for regression models. One inclusion criteria is that the outcome variable ("Y") must be available for a subject to be included in the analysis question (ie. if they did not report a step 2 score, we won't perform relevant step 2 analysis on them).

::: panel-tabset
## Q1 Does order have an impact on Step 2 scores?

We cannot analyze Step 1 since all survey responses reported passing
For Step 2 scores, I will perform a linear regression with:

-   Y = Step 2 score
-   X = factor ( 1 = "step 1 first", 2 = "step 2 first", 3 = "only step 1", 4 = "only step 2")
-   Z = school (need to adjust for this)

::: callout-note
still need to use robust se
:::

```{r}
step2_complete[ ,"order_factor"]  <- factor(step2_complete$exam_order, levels = c(1,2, 3, 4), labels = c("step 1 first", "step 2 first", "only step 1", "only step 2"))
step2_complete[ ,"school_factor"]   <- factor(step2_complete$schoolid, labels = c("HMS", "UVA", "VUMS"))

table(step2_complete$exam_order)

exam_order_mod <- lm(formula = score_step2 ~ order_factor + school_factor, data = step2_complete)
sandwich(exam_order_mod) #this gives the sandwich variance
summary(exam_order_mod) #model summary for reporting
```

Based on the model output (p values), there doesn't appear to be any signifigant associations between exam order and the score for Step 2. Since the $R^2$ value is essentially 0, I conclude that there was no effect of exam order on step 2 scores. 

## Q2 What factors affect Step 2 score?

Again, we cannot analyze Step 1 scores since all respondents reported passing.

Based on our SAP, if there are any covariates with more than 30% of responses missing, we will drop that variable or populate it with 0, depending on context. For example, the percent of Amboss questions completed will be filled with 0 for people who didn't answer since it seems safe to assume they didn't complete any of the Amboss questions. If less than 30% are missing, I may consider performing bootstrap sampling of known values to replace missing values.

After accounting for missingness, I will assess for co-linearity of the predictors (ie. correlation) using VIF. If there is high co-linearity, we will use LASSO to perform variable selection. If there is no evidence of concerning levels of colinearity, I will proceed with linear regression.


```{r data_profile_and_pairs_plots}
#| warning: false

######## profile missingness in the step 2 data and address
percents_missing <- round(colSums(is.na(step2_complete))/nrow(step2_complete), 3)*100
kable(percents_missing, caption = "Percent missing observations for pooled Step 2 survey")

#inspecting percent missing, it seems like most responses are now complete except Amboss. Based on our study plan, I will populate those without a response for Amboss with 0's
step2_complete$amboss_percent_step2 <- ifelse(is.na(step2_complete$amboss_percent_step2) == TRUE, 0, step2_complete$amboss_percent_step2)
class(step2_complete$practicetest_step2) <- "integer"
step2_complete[,"on_target"] <-  factor(step2_complete$target_score_step2, levels = c(1,2,3), labels = c("at target", "above target", "below target"))


# after disucssing with the group, we decided the pairs plots were not helpful to display.
# ######## Making pairs plots to assess co linearity 
# #this function is so I can customize the panels in the correlation pairs plots. 
# tf = function(x,y) {
#   ct <- cor.test(x, y)
#   sprintf("Corr: %0.2f, p: %0.3f\n95%% CI: (%0.2f - %0.2f) \n n pairs = %.0f", 
#           ct$estimate, ct$p.value, ct$conf.int[1], ct$conf.int[2], sum(!is.na(x), !is.na(y))/2)
# }  #https://stackoverflow.com/questions/75068871/add-p-value-and-or-95-ci-in-the-text-of-a-correlation-matrix-pairs-plot
# 
# ggpairs(step2_complete[,c("uworld_percent_step2", "amboss_percent_step2", "length_step2", "practicetest_step2",  "full_test_practice_step2", "practice_score_step2", "practice_test_step2", "on_target", "score_step2")], title="Step 2 scores and predictors pairs plots", upper=list(continuous=wrap("statistic",text_fn=tf,title=NULL, sep=NULL)), progress = FALSE)
```

Multiple linear regression with:

  -   Y = Step 2 score
  
  -   X1 = % UWorld
  
  -   X2 = % Amboss
  
  -   X3 = length study
  
  -   X4 = \# of practice tests
  
  -   X5 = full test day (yes/no code as binary)
  
  -   X6 = final practice score (however, is there some conversion between U World and Amboss - Jeffrey is looking into this)

  -   Z = School (need to adjust for this)

I decided to exclude the number of practice tests (covariate X4) since unique the responses were so few:
 ------------> ACTUALLY NEED TO INCLUDE AND DO DATA CLEANING ON X4!!!
```{r}
unique(step2_complete$practicetest_step2)
table(step2_complete$practicetest_step2)
```

Below I report the model results, sandqich variance, and VIF for step 2 scores model.
```{r}
step2_complete$simulate_full_practice <- ifelse(step2_complete$full_test_practice_step2 <= 2, 0, 1)
step2_complete$simulate_full_practice <- factor(step2_complete$simulate_full_practice, levels = c(0, 1), labels = c("Yes", "No"))
step2_complete$length_step2 <- factor(step2_complete$length_step2 , levels = c(1:6), labels = c("less than 1 week", "1-2 weeks", "3-4 weeks", "5-6 weeks", "7-8 weeks", "more than 8 weeks"))

mod_step2_scores <- lm(score_step2 ~ uworld_percent_step2 + amboss_percent_step2 + length_step2 + simulate_full_practice + practice_score_step2 + school_factor, data = step2_complete)
summary(mod_step2_scores)
sandwich(mod_step2_scores)
vif(mod_step2_scores)

# rms::robcov(mod_step2_scores) this is what I would use to get the robust se estimates but when I try to swtich the above model to ols from the rms package I have trouble getting it to run

# modelsummary::modelsummary(list("Step 2 scores" = rms::robcov(mod_step2_scores)), 
#              output = 'kableExtra',
#              fmt = fmt_sprintf("%.4f"),
#              estimate = "{estimate} [{conf.low}, {conf.high}]",
#              statistic = "p: {p.value}")
```

::: callout-warning
I need help with getting the robust estimator working in my model
:::

I looked into the difference between practice_test_step2 (the final practice test I took before my exam was... 8 options) and practicetest_step2 (text response of how many practice tests did you take before step 2). I decided not to include either in the model.

Based on the model output, practice score is positively associated with final score with p = 0.001.

::: callout-note
I did not perform lasso. would be happy to implement it if we can look it up.
:::

Last time I made the pairs, plot I noticed there is a relationship between

-   "practice test" and "length"

-   "practice score" and "length"

-   "score" and "length" (this makes a lot of sense)

-   practice score and target score (also makes sense)

-   score and target

    a trend (but not below p =0.05) the higher your practice score, the less time you study (makes intuitive sense)

-   uworld percent and target score

## Q3 What is associated (in this data) with pushing back a Step 1 exam date?

Here, I will perform logistic regression with

Y = yes or no (1 = yes, 2 = no for "push_step1")

There may not be sufficient data on this since only 20 people responded that they decided to push back Step 1. The factors that were measured are:

-   push remember step1 (1 = I only remember the form name, 2 = I only remember the score, 3 = I remember the form name and the score, 4 = I don't remember either) - we decided not to include this variable (can change later if desired)

-   push score only step 1 (1 = NBME, 2 = Uworld)

-   push practice test step 1 ( 1 - 8 listing various exams)

-   push nbme practice score (from 0 to 100%)

-   push uw practice score (from 180 to 300)

Listing variables by name and if I have included them:

-   "push_step1_1" yes

-   "push_remember_step1_1" not included b/c a precursor question

-   "push_score_only_step1_1" not currently included but could be

-   "push_practice_test_step1_1" yes

-   "push_nbme_practice_score_step1_1" yes

-   "push_uw_practice_score_step1_1" yes

```{r}
step1_complete$push_step1 <- ifelse(step1_complete$push_step1 == 2 | is.na(step1_complete$push_step1) ==TRUE, 2, 1) #recording the NA's to be "No" (they did not push back step 1)
step1_complete$push_step1_label <- factor(step1_complete$push_step1, levels = c(1, 2), labels = c("Yes", "No")) #making a nice descriptive label

did_push_df <- step1_complete %>% filter(push_step1_label == "Yes")
dat %>% filter(!is.na(push_remember_step1_1))

step1_complete$push_practice_test_step1 <- factor(step1_complete$push_practice_test_step1, levels = c(1:8), labels = c("NBME 25", "NBME 26", "NBME 27", "NBME 28", "NBME 29", "NBME 30", "UWorld 1", "UWorld 2"))

units(step1_complete$push_uw_practice_score_step1) <- "score units"
units(step1_complete$push_nbme_practice_score_step1) <- "percent"
label(step1_complete$push_practice_test_step1) <- "exam that triggered pushing back"
label(step1_complete$push_nbme_practice_score_step1) <- "NBME P(passing) that triggered pushing back"
label(step1_complete$push_uw_practice_score_step1) <- "3 digit UWorld score that triggered pushing back"
caption <- "Description of indiviuals that pushed back Step 1"
table1(~ push_practice_test_step1 + push_uw_practice_score_step1 + push_nbme_practice_score_step1 |push_step1_label, data=step1_complete, topclass="Rtable1-zebra")

```

## Descriptive Statistics (not done yet)

Descriptive statistics will be reported by school and total.

-   histogram of Step 2 scores
-   what resources are most widely used barplot
-   how long did students study barplot
-   number of practice tests histogram (among the people who answered the question)
-   summarize comments (other_resources, other_step, changes_step)

```{r}
## do a plot for all schools (in total) as well as Vanderbilt in particular
## use a unified color scheme

ggplot(aes(x = score_step2), data= step2_complete) + geom_histogram() + theme_minimal() + xlab("Self Reported Step 2 Score") + ylab("Frequency") + labs(title = "Frequency of reported Step 2 Scores")


#more data cleaning first first step 2 for the resouces they selected that they used
resources_step2 <- colSums(took_step2general[20:35])
uworld <- resources_step2[1] + resources_step2[9]
first_aid <- resources_step2[2] + resources_step2[10]
anki <- resources_step2[3] + resources_step2[11]
sketchy <- resources_step2[4] +resources_step2[12]
amboss <- resources_step2[5] + resources_step2[13]
pathoma <- resources_step2[6] + resources_step2[14]
boards_and_beyond <- resources_step2[7] + resources_step2[15]
other <- resources_step2[8] + resources_step2[16]
totals <- c(uworld, first_aid, anki, sketchy, amboss, pathoma, boards_and_beyond, other)

#same idea for step 1
resources_step1 <- colSums(took_step1general[26:41])
uworld1 <- resources_step1[1] + resources_step1[9]
first_aid1 <- resources_step1[2] + resources_step1[10]
anki1 <- resources_step1[3] + resources_step1[11]
sketchy1 <- resources_step1[4] +resources_step1[12]
amboss1 <- resources_step1[5] + resources_step1[13]
pathoma1 <- resources_step1[6] + resources_step1[14]
boards_and_beyond1 <- resources_step1[7] + resources_step1[15]
other1 <- resources_step1[8] + resources_step1[16]
totals1 <- c(uworld1, first_aid1, anki1, sketchy1, amboss1, pathoma1, boards_and_beyond1, other1)

rdf <- data.frame(amount = c(totals, totals1), name = rep(names(totals), 2), step_exam = c(rep("Step 2", 8), rep("Step 1", 8) ))

# http://www.sthda.com/english/wiki/ggplot2-barplots-quick-start-guide-r-software-and-data-visualization used this as a guide

#what resources are most widely used? I want to sort this barplot in order of frequency but for some reason this wasn't working for me with reorder()
ggplot(data=rdf, aes(x=name, y=amount, fill = step_exam)) +
  geom_bar(stat="identity", position=position_dodge())+
  theme_minimal() + coord_flip() + scale_fill_brewer(palette="Blues")



## how long did the students study barplot


## number of practice tests histogram (among the people who answered the question)


## summarize comments (other_resources, other_step, changes_step)
#dat$study_amount_step1_1
```
:::

# Appendix/notes

All the analyses are performed using the following:

-   R version 4.2.2 (2022-06-24); R Core Team (2022). R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna, Austria. URL https://www.R-project.org/.

-   Harrell Jr FE (2022). rms: Regression Modeling Strategies. R package version 6.3-0, <https://CRAN.R-project.org/package=rms>.

The table below lists packages used in this document.

```{r}
subset(data.frame(sessioninfo::package_info()), attached==TRUE, c(package, loadedversion))
```
